1-54(RESTful Webservices and connect to JPA)
------------------------------------------
55. Introduction to Microservices

---->Small autonomous services that work together

--->Style to develop a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API...

These services are build around business capabilities and independently deployable by fully automated deployment machinery..


There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies


As per Ranga, Microservices

Services which are exposed by REST and in addition to that you have small deployable units and these should be Cloud Enabled

Cloud Enabled means---> Having Multiple Instances for each Microservice

Ex: Microservice1  A1  A2
	
Microservice2  B1 B2 B3 B4

Microservice3  C1 


By cloud enabled.. if there is more load i will bring an other instance

-----------------------------------------

56.  Challenges with Microservices

1. Bounded Context

need to identify the right boundary of how many we need 
ex: 10 or 100 Microservices

2. Configuration Management

10 microservices with 5 environments and 50 instances.

3. Dynamic Scale up and Scale Down

The loads will be different at different instances of time.

At particular i might need 2 instances...later i might be needing 10..

So i need to bring up and other older ones to bring down.. and also make sure to bring distribute the load


4. Visibility

identify the bug... like diskspace


5. Pack of Cards

One Microservice calling another..One goes down enitre goes down.


Important to have Fault Tolerance in Microservices

-------------------------------------------------

57. Spring Cloud

cloud.spring.io

you can see wide variety of projects related to Spring cloud


Spring Cloud Netflix

Spring Cloud Config(to provide Centralized external configuration management)


Spring Cloud Bus:
enables microservices and the infrastructure components..like config server and api gateway


We are using Finchley M2 Release of Spring Cloud


Challenges:

1. Configuration Management:

Spring Cloud Config server: Provides an approch where you can store all the configuration for all the different environments of all the different microservices in a Git Repository..(storing at one place)


Spring Cloud Config server can be used to expose that configuration to all the microservices..

Helps to keep the configuration at one place and that makes very easy to maintain the configuration for all the microservices.


2. Dynamic Scale up and Scale Down

>Naming Server(Eureka)
>Ribbon (Client Side Load Balancing)
>Feign (Easier REST Clients)


Diagram:
	CurrencyCalculationService

		Ribbon->NamingServer

CurrecyExchangeService1     2               3


Ribbon distributing to 1 2 3...Ribbon Load Balancing


Solution is 

1. Naming Server(Eureka)--->All the instances of all microservices would register with the namingserver..

Features: 

i) Service Registration--->All the Microservices can register with Microservice

ii) Service Discovery--> CurrencyCalculationService can ask Eureka Naming server(give me the current instances of CurrencyExchangeService) and the naming service would provide those URLs to currency Calculation service...

This helps to establish dynamic relationship btwn CurrencyCalculationService and the instances of CurrencyExchangeService

We will use Ribbon for Client Side Load Balancing...That means CurrencyCalculationService will host ribbon...

Ribbon will make sure the load is evenly distributed among the exisitng instances that it gets from Naming Server...


We will also use Feign in the CurrencyCalculationService as a mechanism to write simple RESTful Clients


3. Visibility and Monitoring(solutions are below)

i) Zipkin Distributed Tracing 
ii) Netflix API Gateway


We use Spring Cloud Slouth to assign a id to the request across multiple components

We use Zipkin Distributed Tracing to trace a request across multiple components

One of the important thing aboout microservices is....have lot of common features like logging, security, analytics..


we dont want to implement each and every microservice... this is where API Gateway is used..


4. Fault Tolerance


If a service is down, Hystrix helps us to configure default response


---------------------------------------

58. Advantages of Microservices architecture.

1. New Technology and Process Adaption

2. Dynamic Scaling(if your microservices are cloud enabled they can scale dynamically) you can scale up and scale down.

3. Faster release cycles(Developing smaller components it is much easier to release microservices) you can bring new features faster to market

-----------------------------------------------------

59. Microservices components- Standardizing Ports and URL

Code and URLS part available in below link


https://github.com/in28minutes/spring-microservices/tree/master/03.microservices

---------------------------------------------------

60. Intro to limits Microservice and Spring Cloud Configure Server


* Each of this microservices has its own configuration. 
(database, externalized service, business logic configuration)


1. Currency Conversion Service(Arrows--top to bottom)


Dev	QA      Stage   Prod

Dev1  QA1 QA2   Stage1	Prod1


2. Currency Exchange Service(Arrows--top to bottom)


Dev	QA      Stage   		Prod

Dev1  QA1 QA2   Stage1	  Prod1  Prod2   Prod3    Prod4



Each of Microservices(Currency Exchange Service) there are multiple environments and some of these environments 
might have multiple instances of the same microservice...

We are managing configuration of lot of differnt instances of different Microservices.....

Managing the configuration individually for each application in each environment is very difficult and thats where Centralized Configuration comes into Picture


SpringCloudConfigServer says you put all the configuration for your applications in Git repository and i would take care of managing configuration and providing it to the specific microservice


Diagram:(Arrows from top to bottom)


CurrencyCalculationService C_Exchange_S  LimitsService

		 SpringCloudConfigServer 

			Git


Ex: i would need configuration for Dev environment for LimitsService, SpringCloudConfigServer would able to provide it to it..Similary for other service want some particular thing...SpringCloudConfigServer would able to provide it


SpringCloudConfigServer would acts as Centralized microservice configuration

-------------------------------------------------
63. Creating a hard coded limits service

In application.properties
spring.application.name=limits-service

Create LimitsConfigurationController.java
--->use a GetMapping for a method to return max and min

Create LimitConfiguration.java
--->initialize max and min variables
-->Generate only getters
-->Generate construcotrs using fields
-----------------------------------------------------
64. Get configuration from application.properties

In application.properties 

limits-service.minimum=99
limits-service.maximum=9999

One way is that

Create Configuration.java



//prefix taken from app.props and added in brackets

@ConfigurationProperties("limits-service")

private int maximum;
private int minimum;

generate getters and setters


In LimtsConfigurationController.java

in order to use the Configuration...need to autowired

@Autowired
private Configuration configuration;


change the return type from previous hardcoding

------------------------------------------------------

65. Setting up Spring Cloud Config server

start.spring.io

same group id
spring-cloud-config-server


DevTools, Config Server


In application.properties

spring.application.name=spring-cloud-config-server
server.port=8888
------------------------------------------------

66. Installing Git

Type Git in google.. Download exe on your system


---------------------------------------

67. in cmd

mkdir git-localconfig-repo
cd git-localconfig-repo/
git init

right click on the spring-cloud-config-server-->BuildPath--->Link Source-->Browser to the folder(git-localconfig-repo)-->finish

right click on git-localconfig-repo---> File name is 
limits-service.properties

copy the application.properties of limits-service and paste to git-localconfig-repo-->limits-service.properties

we need to add the file to local git repository

git add -A

git config --global user.email "homehum333@outlook.com"

git commit -m "first commit"

(You will get 1 file changed, 2 insertions(+)


---------------------------------------------

68. Connect Spring Cloud Config server to local Git repository
-----------

right click on git-locaconfig-repo and select properties and copy the location


In application.properties

spring.cloud.config.server.git.uri= file:\\E:/2020/git-localconfig-repo

go to localhost:8888/limits-service/default


You need to enable SpringCloudConfigServer on application class...

@EnableConfigServer


SpringCloudConfigServer stores configuration for multiple services...Like LimitsService etc etc

Also it can store configuration for each of the services for different environments

EX: LimitsService has 4 environments...We can store all the configuration related using SpringCloudConfigServer.

------------------------------------------------
69. Configuration for Multiple Environments in Git Repository


create limits-service-dev.properties
create limits-service-qa.properties

once you made changes to above properties

make sure you are committing

git add -A
git status

git commit -m "Dev and QA properties"


Run as Java application


now the URL changed:

Ex: localhost:8888/limits-service/qa


-----------------------------------------------

70. Connect Limits Service to Spring Cloud Config server


In LimitsService--->change the application.properties name to bootstrap.properties


spring.cloud.config.uri=http://localhost:8888

application.name is the critical part in bootstrap.properties


Run as Java Application to LimitsServiceApplication

We connected LimitsService to SpringCloudConfigServer... 


----------------------------------------------

72. Configuring Profiles for Limits Service


In bootstrap.properties


spring.profiles.active=dev

we will get the values from dev as we said is dev

lets try to remove the maximumm value from limits-service-dev.properties


then you need to go to git and commit them to get reflected the changes


git add *;
git status

git commit -m "removed configuration for maximum"

stop and start of LimitsConfiguration.java

-------------------------------------------

73. A review of SpringCloudConfigServer


Used to manage all the configuration related to multiple microservices..

Each config for differnt environments

We just need to create with specific naming conventions in the Git repo and commit them...

Then we can connect to SpringCloudConfigServer to the Git Repository and able to serve those configurations.

we connected Limitservices to SpringCloudConfigServer to pick the values from Git repository


Ex: You want another microservice 

1. you have to create those configuration in git repository and commit them


ex: Curreny-Exchange-Service-qa.properties

2. Connect the CurrencyExchangeService to the SpringCloudConfigServer

we will rename it bootstrap.properties and put the uri for SpringCloudConfigServer

-----------------------------------------------

74. Introduction to CurrencyConversion and CurrencyExchangeService

Nothing is derr
----------------------
75. Nothing
-------------------
76. Setting up the Currency Exchange service


start.spring.io

samegroupid
currency-exchange-service is the artifactid

Web, DevTools, Actuator, ConfigClient


in application.properties

spring.application.name=currency-exchange-service
server.port=8000

-------------------------------------

77. Create a Simple Hard coded currency exchange service

Create a CurrencyExchangeController.java


@RestController
public class CurrencyExchangeController {


@GetMapping("/currency-exchange/from/{from}/to/{to}")

public ExchangeValue retrieveExchangeValue
(@PathVariable String from, @PathVariable String to){

return new ExchangeValue(1000L, from, to, BigDecimal.valueOf(65));

Run as java application


URL: localhost:8000/currency-exchange/from/USD/to/INR
----------------

Create ExchangeValue.java

public class ExchangeValue {

private Long id;
private String from;
private String to;
private BigDecimal conversionMultiple;

public ExchangeValue() {


Generate Constructor using fields
Generate Getters and setters

------------------------------------------------
78. Dynamic Port setting up in the Response


(Arrows top to bottom) starting from ExchangeService

Diagram
CurrencyCalculationService-->ExSe-->LimitsService

			     DB      Configuratin



Adding a port to the CurrencyExchangeService response

In ExchangeValue.java
----------------------
private int port;

Generate both getters and setters 

Go to CurrencyExchangeController.java
-------------------
@Autowired
private Environment environment;

ATL shift L----> exchangeValue

exchangeValue.setPort(Integer.parseInt(environment.getProperty("local.server.port")));

-------------------

I want multiple instances to run this..
ex: 8000 and 8001

RunConfigurations--->add8000 to the name(on top bar)---->Right Click and select duplicate(on left side bar) and rename to 8001

Now for 8001--->VM arguments-->
-Dserver.port=8001--->Apply--->Run



URL: localhost:8000/currency-exchange/from/USD/to/INR

URL: localhost:8001/currency-exchange/from/USD/to/INR
---------------------------------------

79. Configure JPA and Initialized Data

go to pom.xml

add spring-boot-starter-data-jpa
add com.h2database

in ExchangeValue.java
--------------------------
@Entity

@Id

@Column(name="currency_from")

@Column(name="currency_to")
-------
New-SQLFile-->Data.sql

insert into exchange_value(id,currency_from,currency_to,conversion_multiple,port)
values(10001,'USD','INR',65,0);

insert into exchange_value(id,currency_from,currency_to,conversion_multiple,port)
values(10002,'EUR','INR',75,0);

insert into exchange_value(id,currency_from,currency_to,conversion_multiple,port)
values(10003,'AUD','INR',25,0);


-----------------------------

in application.properties

spring.jpa.show-sql=true
spring.h2.console.enabled=true


------------------

localhost:8000/h2-console

jdbc:h2:mem:testdb

you will able to see exchangevalue table


SELECT*FROM EXCHANGE_VALUE


---------------------------------------

80. Create a JPA Repository


Create ExchangeValueRepository.java(interface)


public interface ExchangeValueRepository extends JpaRepository<ExchangeValue, Long>{

ExchangeValue findByFromAndTo(String from, String to);

}
------------------------
in ExchangeValueController.java
-----------------------------
@Autowired
private ExchangeValueRepository repository;

//remove Bigdecimal.valueOf(65) and replace with below

ExchangeValue exchangeValue= repository.findByFromAndTo(from,to);

URLS:

localhost:8000/currency-exchange/from/USD/to/INR

localhost:8000/currency-exchange/from/EUR/to/INR

localhost:8000/currency-exchange/from/AUD/to/INR


----------------------------------------------------

81. Create a CurrencyConversion MicroService


start.spring.io

com.golive.microservices

currency-conversion-service

Web, DevTools, Actuator, Config Client


in application.properties

spring.application.name=currency-conversion-service
server.port=8100

----------------------------------------

82. Creating a service for currency conversion


Create a CurrencyConversionController.java
---------------
@RestController
public class CurrencyConversionController {


@GetMapping("/currency-converter/from/{from}/to/{to}/quantity/{quantity}")

public CurrencyConversionBean convertCurrency(@PathVariable String from, @PathVariable String to,@PathVariable BigDecimal quantity)
 {

return new CurrencyConversionBean(1L, from, to, BigDecimal.ONE, quantity,quantity,0);
------------------------------
Create a CurrencyConversionBean.java
----------------------
private Long id;
private String from;
private String to;
private BigDecimal conversionMultiple;
private BigDecimal quantity;
private BigDecimal totalCalculatedAmount;
private int port;

public CurrencyConversionBean(){
}

Generate Getters and setters
Generate Constructors using Fields



URL: localhost:8100/currency-converter/from/USD/to/INR/quantity/1000

---------------------------------------------

83. Invoking CurrencyExchange service CurrencyConversion service

Go to CurrencyConversionController.java

//What we will do is we are calling the CurrencyExchangeService(other service) into our CurrencyConversionService

//We are setting uriVariables...we are calling it..and we are getting the response back(.getBody), taking it into the bean and we are creating the new response bean by using the content which is present in the response


// Feign - Problem 1
Map<String, String> uriVariables = new HashMap<>();
uriVariables.put("from", from);
uriVariables.put("to", to);

		ResponseEntity<CurrencyConversionBean> responseEntity = new RestTemplate().getForEntity("http://localhost:8000/currency-exchange/from/{from}/to/{to}", CurrencyConversionBean.class,uriVariables);

CurrencyConversionBean response = responseEntity.getBody();

return new CurrencyConversionBean(response.getId(), from, to, response.getConversionMultiple(), quantity,
				quantity.multiply(response.getConversionMultiple()), response.getPort());
---------------------------
Run the CurrencyExchangeServiceApplication8000

Both has to be up...

URI: localhost:8000/currency-exchange/from/EUR/to/INR

URI: localhost:8100/currency-converter/from/USD/to/INR/quantity/1000


o/p:

{
    "id": 10001,
    "from": "USD",
    "to": "INR",
    "conversionMultiple": 65.00,
    "quantity": 1000,
    "totalCalculatedAmount": 65000.00,
    "port": 8000
}

-----------------------------------------

84.

We recommend using 2.1.3.RELEASE version of Spring Boot from here on in the course.

Use Spring Cloud - Greenwich.RC2 and Spring Boot - 2.1.3.RELEASE.

Make these changes in all your pom.xml files. Save and Restart. You are all set.

Change 1

<parent>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>2.1.3.RELEASE</version>
<relativePath/> <!-- lookup parent from repository -->
</parent>
Change 2

<spring-cloud.version>Greenwich.RC2</spring-cloud.version>

-------------------------------------

85. Using Feign REST client for Service Invocation


Add a dependency..

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifcatId>spring-cloud-starter-openfeign</artifactId>
</dependency>


In CurrencyConversionServiceApplication

@EnableFeignClients("com.golive.microservices.currencyconversionservice")

-----

Create CurrencyExchangeServiceProxy.java(interface)

@FeignClient(name="currency-exchange-service", url="localhost:8000")
public interface CurrencyExchangeServiceProxy{


@GetMapping("/currency-exchange/from/{from}/to/{to}")

public CurrencyConversionBean retrieveExchangeValue
	(@PathVariable("from") String from, @PathVariable("to") String to);
}
}


---------------------

In CurrencyConversionController.java
----------

@Autowired
private CurrencyExchangeServiceProxy proxy;


//Feign-problem-2
@GetMapping("/currency-converter-feign/from/{from}/to/{to}/quantity/{quantity}")

public CurrencyConversionBean convertCurrencyFeign(@PathVariable String from, 
		@PathVariable String to,
		@PathVariable BigDecimal quantity)
 {
	
//only this is changed..rest is same..removed Map and other


CurrencyConversionBean response = proxy.retrieveExchangeValue(from, to);


return new CurrencyConversionBean(response.getId(), from, to, response.getConversionMultiple(), quantity,quantity.multiply(response.getConversionMultiple()),response.getPort());
}}


URI:
localhost:8000/currency-exchange/from/USD/to/INR

localhost:8100/currency-converter/from/EUR/to/INR/quantity/1000

localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

-----------------------------------------

86.  setting up client side load balancing with Ribbon

Diagram:

CurrencyCalServ-> CExServ-->LimitsService

		  Database  Configuration



Only one instance of CurrencyConversionService can talk to One instance of CurrencyExchangeService

I want to distribute load between all the instances..thats where Ribbon comes into picture

Ribbon can make use of the feign configuration and help us distribute the calls between different instances of the CurrencyExchange service..

Diagram(Top to bottom):

		CurrencyCalculationService

		Ribbon-->NamingServer

CurrencyExServ1		CES2		CES3

go to pom.xml

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-ribbon</artifactId>
</dependency>

if not works use this:(worked for me)
spring-cloud-starter-netflix-ribbon

-------------------
Go to CurrencyConversionServiceProxy.java

//commented the url part
@FeignClient(name="currency-exchange-service")
@RibbonClient(name="currency-exchange-service")


go to application.properties(currency-conversion)

currency-exchange-service.ribbon.listOfServers=http://localhost:8000,http://localhost:8001

------------------------------------------
87. Running Client side load balancing with Ribbon

make sure that currencyExchangeserivce(8000 and 8001) are up and running 

URI: localhost:8000/currency-
exchange/from/EUR/to/INR

localhost:8000/currency-exchange/from/EUR/to/INR


give this uri and start refresh you can see the below output and the ports are exchanged between 8000 and 8001

----------------
localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

{
    "id": 10001,
    "from": "USD",
    "to": "INR",
    "conversionMultiple": 65.00,
    "quantity": 1000,
    "totalCalculatedAmount": 65000.00,
    "port": 8000
}

-------------------------------------------------
89. Need of Naming server


I want to increase or decrease the services as per the load.. that is where NamingServer comes


Diagram:(all arrows are pointing from top to bottom)


CurrencyCalculationService CES	LimitsService

		EurekaNamingServer



All the instance of all microservices would register with NamingServer..This is called ServiceRegistration

Ex: If CurrencyCalculationService would like to talk with CurrencyExchangeService then  CurrencyCalculationService would talk to the Naming server and it would ask the NameServer what are the instances of the CurrencyExchangeService 
that are currently running. This is called ServiceDiscovery


----------------------------------------------

90. Setting up Eureka Naming server

 
start.spring.io

com.golive.microservices -----> groupId

netflix-eureka-naming-server  ---->artifactId

dependencies: eureka server, Actuator, DevTools, ConfigClient

----

go to NetflixServiceApplication.java

@EnableEurekaServer


Go to application.properties


spring.application.name=netflix-eureka-naming-server
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false


URI: localhost:8761

----------------------------------

91. Connecting CurrencyConversion Microservice to Eureka

go to CurrencyConversion pom.xml

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-eureka-client</artifactId>
</dependency>

//below worked for me

spring-cloud-starter-netflix-eureka-client(if above doesn't work)


Go to CurrencyConversionServiceApplication.java
-------------------
@EnableDiscoveryClient

//configure the url for Eureka

in application.properties

eureka.client.service-url.default-zone=http://localhost:8761/eureka

Launch up the CurrencyConversionServiceApplication(8100)

URI: localhost:8761

//You can now see the instances of CurrencyConversionService registered with Eureka


----------------------------------------

92. Connecting CurrencyExchange Microservice to Eureka


go to CurrencyExchange pom.xml

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>


go to CurrencyExchangeServiceApplication.java

@EnableDiscoveryClient

in application.properties

eureka.client.service-url.default-zone=http://localhost:8761/eureka


Launch up the CurrencyExchangeServiceApplication(8000 and 8001)

URI: localhost:8761

//You can now see the instances of CurrencyConversionService registered with Eureka


similarly connect LimitsService to EurekaNamingServer

-------------------------------------------------------------------93. Distributing Calls using Eureka and Ribbon

in currency-conversion-service (application.properties)


#the url part(Kind of disabling)


1. Kill all the apps that are running
2. First Start Netflix
3. start CurrencyExchange 8000
4. start CurrencyConversion 8100
5. start CurrencyExchange 8001
6. Stop CurrencyExchange 8000


URI: localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

-------------------------------------------------------------

95. A review Eureka, Ribbon, Fegin


CurrencyCalculationService is the Consumer of the CurrencyExchangeService ( we had url part in starting)...

To able to get load balancing we introduced the Ribbon..before that feign was used for CurrencyCalculationService to make it easy to call restservices with CurrencyExchangeService. 

 

We added Ribbon load balancing between instances of CurrencyExchangeService (calls that are coming from CurrencyCalculationService were distributed b/wn two instances of the CurrencyExchangeService)..we hardcoded that via urls in CurrencyConversionService

We connected CurrencyCalculationService and CurrencyExchangeService to the NamingServer


Naming server offers service registration and service discovery

Ribbon provide client side load side balancing(b/wn service providers)

Feign to make sure that the code we write inside the CurrencyCalculationService to call the CurrencyExchangeService is very simple

-----------------------------------------------------------
96. API Gateways

*Authentication, authorization and security
*Rate Limits
*Fault Toleration(default response back if not up)
*Service Aggregation(external consumer want to call 15 services..better to aggregate 15 services and call one service)

Features are implemented at the level of Api gateways

instead of allowing the Microservices to call each other directly.. What we will do we allow all the calls to go through the API gateway and it will take care providing common features above of the above.

Provides Aggregation services across microservices

great place for debugging as well as doing analytics.
------------------------------------------------------

97. Setting up Zuul Gateway


1. Create a component for Zuul api gateweay server
2.  what Zuul api gateway has to do when intercepts a request
3. right reuqest to go through the zuul api


Start.spring.io

com.golive.microservices
netflix-zuul-api-gateway-server


Zuul, eurekaDiscovery, actuator, devtools

---------------------
GatewayApplication.java

@EnableZuulProxy
@EnableDiscoveryClient

-------------------
in application.properties
----------------

spring.application.name=netflix-zuul-api-gateway-server
server.port=8765
eureka.client.service-url.default-zone=http://localhost:8761/eureka


-------------------------------------------------

98. Implementing Zuul logging filter

Create ZuulLoggingFilter.java


@Component
public class ZuulLoggingFilter extends ZuulFilter{




private Logger logger= LoggerFactory.getLogger(this.getClass);

Add Unimplemented methods

filterOrder()
return 1;

shouldFilter()
return True;

filterType()
return "pre";

//logic in run(){


@Override
public Object run() {

HttpServletRequest request = 
				RequestContext.getCurrentContext().getRequest();

logger.info("request -> {} request uri -> {}", 
request, request.getRequestURI());

return null;
------------------------------
99. Executing a request through Zuul Api Gateway

before launching zuul app

1. Eureka has to up
2. conversionservice to be up(8100)
3. CurrencyExchange
4. then zuul app



//request to go through Zuul api gateway

http://localhost:8765/{application-name}/{uri}

ex: 

Main URI: http://localhost:8765/currency-exchange-service/currency-exchange/from/USD/to/INR

Normal URI: localhost:8000/currency-exchange/from/USD/to/INR
----------------------------------------------
100. Setting up Zuul Api between Microservices
-------------
Go to the CurrencyExchangeServiceProxy.java

//comment out the @FeignClient(name="currency-exchange-service")

//comment out the @GetMapping bcoz we are now having a new URI that is passing through Gateway

@FeignClient(name="netflix-zuul-api-gateway-server")

@GetMapping("/currency-exchange-service/currency-exchange/from/{from}/to/{to}")


we need all 4 apps to be running

1. NetflixZuulAppGatewayServerApplication
2. CurrencyConversionSeriveApplication8100
3. CurrencyExchangeServiceApplication8000
4. NetflixEureakNamingServerApplication

URI: localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

URI: http://localhost:8765/currency-conversion-service/currency-converter-feign/from/USD/to/INR/quantity/1000


-------------------------------------

102. Distributed Tracing

I would need to have one single centralized where i can check what is happening with specific request...


We use Spring-cloud-Sleuth with zipkin...

Assign a unique Id to a request...


Spring-cloud-slouth will Assign a unique Id to a request---So that i can trace it acrros components


zipking---we called Distributed Tracing system...

all the logs from all these services we would put it into the Rabbit MQ and we would send it out to the zipkin server where it will be consolidated and we were able to look through the request and find 
what is happening with specific request.


------------------------------------------
103. Implementing Spring Cloud Sleuth

//add a unique id to the request..

//implementing in currency-conversion-service
Currency-exchange-service and netflix-zuul-api gateway-server.


Go to netflix-zuul-api gateway-server

in pom.xml

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>

//what requests we want to trace= ALWAYS_SAMPLER


In NetflixZuulApiGatewayServerApplication.java

@Bean
public Sampler defaultSampler(){
return Sampler.ALWAYS_SAMPLE;

//do same changes for 
currency-conversion-service
currency-exchange-service


In currency-exchange-controller and 
In currency-conversion-controller we are adding LoggerFactory..

private Logger logger= LoggerFactory.getLogger(this.getClass());


logger.info("{}",exchangeValue);

logger.info("{}",response);
-------
clear the console for all the applications

URI: localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

i can see unique id generated sometimes in the console

ex:
2020-05-21 00:03:01.987  INFO [currency-exchange-service,1b0563b12f8ab260,c3c2f7fd5d831109,true]

--------------------------------------------------

104. Distributed Tracing with Zipkin

Diagram: arrows only from top to bottome
--------------------


CurrencyCalucltionServie CES 	LimitsService

		      RabbitMQ

	  ZipkinDistributedTracingServer

		      Database


whenver there is log message it will put it on the RabbitMQ and therby ZipkinDistributedTracingServer would be picking up from RabbitMQ 

-----------------------------------------

105. Installing Rabbit MQ

https://www.rabbitmq.com/install-windows.html


brew install rabbitmq

/usr/local/sbin/rabbitmq-server



1. type and go to (sbin dir)from start menu

2. rabbitmq-plugins enable rabbitmq_management

3. http://localhost:15672

username and password: guest

---------------------------------

106. Zipkin on Windows

If you get a 404 while downloading the jar, use the curl command to download :

curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar

---------------------------

107. Setting up Distributed Tracing with Zipkin


download zipkin using zipkin quickstart


java -jar zipkin-server-2.21.1-exec.jar



URI: http://localhost:9411/zipkin/


SET RABBIT_URI=amqp://localhost

java -jar zipkin-server-2.21.1-exec.jar

---------------------------------------
108. Connect microservices to zipkin 

go to NetflixZuulApiGatewayServer 

in pom.xml add below

<dependency>			
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-zipkin</artifactId>
		</dependency>

		<dependency>		
		<groupId>org.springframework.amqp</groupId>
		<artifactId>spring-rabbit</artifactId>
		</dependency>

copy same dependencies in currencyexchange and currencyconversionservice pom.xml


------------------------------------------
109.

New Dependencies

<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>

<dependency>		
<groupId>org.springframework.amqp</groupId>
<artifactId>spring-rabbit</artifactId>
</dependency>

-----------------------------------------------------

110. Using Zipkin UI Dashboard to trace requests

make sure all the below are running 




1. EurekaNamingServer 
2. ZipkinDistributedTracingServer(Via Cmd)
3. CurrencyConversionSeriveApplication8100
4. CurrencyExchangeServiceApplication8000
5. NetflixZuulAppGatewayServerApplication



URI: localhost:8100/currency-converter-feign/from/USD/to/INR/quantity/1000

URI: http://localhost:9411/zipkin/


serviceName currency-conversion-service(click on search)

just check with the traces

-----------------------------------------------------


112. Need of Spring Cloud Bus


make sure you are launching 

1. SpringCloudConfigServerApplication
2. LimitsServerApplication


URI: localhost:8080/limits

Duplicate the LimitsServiceAppication

-Dserver.port=8081 


Apply and Run

URI: localhost:8081/limits


if you change the application.properties values..

then you need to commit


in Git ---direct to the folder path


git status


git add *
git commit -m "qa minimum to 22"


//changes are not getting reflected...Go to POSTMan
and we need to fire a POST request
--------------------------------
URI: http://localhost:8080/actuator/refresh

----------------------------------
in limits-service.properties 

management.security.enabled=false

//Enable all Actuator URLs 

management.endpoints.web.exposure.include=*

//reverted the changed values in limits-service-qa.properties(this is in spring-cloud-config-server project where in git-local-repo folder)


and restart the application

git add *
git commit -m "qa minimum to 2"


and restart the application-worked

//again making changes


git add *
git commit -m "qa minimum to 22"

//not reflected in URIs

Go to POSTMan
and we need to fire a POST request
--------------------------------
URI: http://localhost:8080/actuator/refresh

----------------------------------
URI: http://localhost:8081/actuator/refresh



The above is a headache and thats where Spring Cloud Bus can help us

-------------------------------------------------

113. Implementign Spring Cloud Bus

//we are using RabbitMq

//add in limits-service-server 

in pom.xml


<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>


in bootstrap.properties

management.security.enabled=false

//Enable all Actuator URLs 

management.endpoints.web.exposure.include=*

Launch up spring-cloud-config-server and 2 instances of limts-service

check the http://localhost:8080/limits and http://localhost:8081/limits

open limits-service-qa.properties and change the values


go to POSTMan(fire a POST request)
-------------------------------

URI: http://localhost:8080/actuator/bus-refresh
-------------------------------------

At application startup all the microservices instances register with cloud bus


when there is anychange in configuration...whenver refersh is called on any of the instances the microservices instance would sent an event over to spring cloud bus...would propagate the event to all the microservices instances  that are registered with it.

--------------------------------------------------------------------

114. Fault Tolerance with Hystrix

if any one of these microservices is down then they can pull down the entire chain of microservices that are invoking them...

Ex: CCs depends on CES and CES depends on LimitsService... if LimitsService is down then previous 2 goes down...That is not good..


That is where Fault toleracne comes into picture..


Can LimitsService provide some graceful behaviour..Atleast gives some good repsonse...prevent entire chain in going down..


Hystrix helps us to build Fault tolerance microservices..


//limits-service(pom.xml)


	      
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-hystrix</artifactId>
    <version>1.4.7.RELEASE</version>
</dependency>

---------
Go to LimitsServiceApplication and enable it

@EnableHystrix
------

Go to LimitsConfigurationController.java
----------------------------------
@GetMapping("/fault-tolerance-example")
@HystrixCommand(fallbackMethod="fallbackRetrieveConfiguration")

public LimtiConfiguration retrieveConfiguration(){
throw new RuntimeExcpetion("Not available");
}


public LimtiConfiguration fallbackRetrieveConfiguration(){
return new Limitconfiguration(999,9);
}


Start LimitsServiceApplication

URI: localhost:8080/fault-tolerance-example


{"maximum":999,"minimum":9}


//If i am not able to talk to application and retrieve values the I am providing a default behaviour
-----------------------------------------------------------




















